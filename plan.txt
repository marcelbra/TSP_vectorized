Wir kriegen als Input 2 Arrays:
	- cityX sind X-Koordinaten der Städte
	- cityY sind Y-Koordinaten der Städte.

Wir initialisieren dann NumberOfCities*NumPointFactor Punkte (z.b. bei 5 Städten 5*2=10 Punkte) je mit x und y Koordinate.
Diese Punkte sind dann unser "elastisches Netz", das wir iterativ auf die Stadtkoordinaten zubewegen wollen, um
eine Rundreise zu erhalten.

Ablauf dann:
	1. Normalisiere Input-Vektoren auf [0, 1]
	2. Initialisiere das "Netz" in pointX, pointY (je Arrays) als Kreis um (0,0) mit Radius 0.1 und NumPointFactor 2.5
	3. Initialisiere K=0.1, K_update = 25, alpha=beta=1
	4. Dann iterativ "Evolution":
		Solange max Dist Stadt<->nächster Punkt > 0.009 und Anzahl Iterationen < 20k:
			- Temperatur-Koeffizienten K updaten auf K = max(0.01, 0.99*K) (sinkt mit den Iterationen, damit das Netz am Ende nicht mehr so hin- und herspringt),
			  falls es eine K-Update-Period ist (nur alle z.B. 25 iterationen wird geupdated)
			- v_ia ausrechnen pro Punkt (Formel auf Folie 7)
			- Temperatur T = 2*K^2 updaten
			- Verschiebungen der Netz-Punkte berechnen ("Δy_a" in Folie 7 (die große Formel))
			- Verschiebungen auf Netz-Punkte addieren


Implementierung:
	class ElasticNet:
		variables:
			float alpha, beta = 1.0
			float K = 0.1
			int K_update = 25
			float_arrays cityX, cityY = Null (werden übergeben)
			float_arrays pointX, pointY = Null
			float radius = 0.1
			int num_point_factor = 25			

		functions:
			constructor(alpha, beta, ...):
				// set variables, call constructor_net()
			construct_net():
				// initialize pointsX, pointsY and scale city and net
				1. initialisiere pointsX, pointsY.
				2. skaliere pointsX, pointsY, cityX, cityY mit normalize()
			normalize():
				// nimmt Vektor, skaliert Werte auf [0, 1]
			evolution():
				// do one evolution (also einmal 4. oben)
			get_vectors():
				// für die Visualisierung

				
			
